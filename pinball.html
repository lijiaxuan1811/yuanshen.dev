<!DOCTYPE html>
<html>
	<head>
		<meta charset="GB2312">
		<title>YuanRetro-JS弹球</title>
		<link rel="stylesheet" href="./style.css">
	</head>
	<body class="body">
		<ul>
			<li class="navi"><a href="http://www.yuanshen.dev/">主页</a></li>
			<li class="navi"><a href="http://www.yuanshen.dev/music.html">音乐</a></li>
			<li class="navi"><a href="http://www.yuanshen.dev/pinball.html">JS弹球</a></li>
			<li class="navi"><a href="http://www.yuanshen.dev/crtirgen.html">中国铁路行程信息提示生成器(CRTIRGen)</a></li>
			<li class="navi"><a href="http://www.yuanshen.dev/about.html">关于</a></li>
			<li class="navi"><a href="http://www.yuanshen.dev/en/index.html">English</a></li>
		</ul>
		<br />
		<h2>弹球游戏 V2.0 <del>更新日期未知</del></h2>
		<p>用纯JavaScript写的小小游戏，可以分别用键盘的“a”和“d”键控制挡板左右移动，也可以使用<del>（移动设备不友好）</del>的按钮哦~<br />如果浏览器不支持或者屏蔽了JavaScript，游戏可（ken）能（ding）就不能运行了哦~<br />每次接住弹球可以得到5分，但是如果没接住的话，就寄喽~</p>
		<p>感谢<del>（n年前买的x）</del>程晨的《JavaScript网页游戏制作轻松学》(ISBN 978-7-115-46238-1)，这里的算法和部分代码参考了书中的思路哦~</p>
		<!--创建400x400像素的画布-->
		<canvas id="canvas" width="400" height="400"></canvas>
		<script type="text/javascript">
			var canv = document.getElementById("canvas");
			var ctx = canv.getContext("2d"); //创建画布和画笔对象
			//声明一些杂七杂八的变量
			var startX = 0;
			var startY = 0;
			var panelX = 0;
			var flag = false;
			var score = 0;
			//var testI = 0;
			function debounce(func, wait, imme) {
				//防止键盘按下某个按键之后连续114.5(x)次的重复情况
				//参数func是传入的需要通过按键执行的方法，wait是如果连续执行则每次执行的间隔时间（毫秒）
				//布尔类型参数imme如果被设置为“true”则取消等待时间（那你为啥还要用这个方法x）
				//参（chao）考（de）以下帖子中的代码，作者为Peter Mortensen
				//https://www.stackoverflow.com/questions/24004791/what-is-the-debounce-function-in-javascript/24004942#24004942
				var timeout;
				return function() {
					var context = this,
						args = arguments;
					var callNow = imme && !timeout;
					clearTimeout(timeout);
					timeout = setTimeout(function() {
						timeout = null;
						if (!imme) {
							func.apply(context, args);
						}
					}, wait);
					if (callNow) {
						func.apply(context, args);
					}
				}
			}

			function prep() {
				//随机生成弹球和挡板的初始位置坐标
				//只有生成的数在某一个范围内才跳出死循环（看起来很危险的样子，不过实际上几乎不会超过几毫秒x）
				//确实有用数学运算的优化方法，但是实在不（lan）想（de）改代码了
				//10 px<startX<390 px: 避免球卡进左右边框
				//10 px<startY<380 px: 避免球卡进上下边框或者一开局就gg（当然还是有可能的）
				//0 px<panelX<350 px: 避免挡板卡进左右边框
				while (true) {
					startX = Math.floor(Math.random() * 1000);
					if (startX > 10 && startX < 390) {
						break;
					} else {
						continue;
					}
				}
				while (true) {
					startY = Math.floor(Math.random() * 1000);
					if (startY > 10 && startY < 380) {
						break;
					} else {
						continue;
					}
				}
				while (true) {
					panelX = Math.floor(Math.random() * 1000);
					if (panelX > 0 && panelX < 350) {
						break;
					} else {
						continue;
					}
				}
			}
			prep();
			var ball = {
				//声明弹球的基本属性
				//包括初始坐标，下一步的移动速度和一些方法
				x: startX,
				y: startY,
				//移动速度，正负分别代表不同方向
				xSpeed: -2,
				ySpeed: -2,
				draw: function() {
					ctx.fillStyle = "Red";
					ctx.beginPath();
					ctx.arc(this.x, this.y, 10, 0, Math.PI * 2, false); //在画布上画出弹球
					ctx.fill();
				},
				move: function(panelSt, panelEn) {
					if (this.x + this.xSpeed < 10 || this.x + this.xSpeed > 390) {
						this.xSpeed = -this.xSpeed; //碰左右壁，反弹
					} else {
						this.x += this.xSpeed; //继续移动
					}
					if (this.y + this.ySpeed < 10 || this.y + this.ySpeed > 390) {
						this.ySpeed = -this.ySpeed; //碰顶，反弹
					} else if (this.y + this.ySpeed >= 380 && this.y + this.ySpeed <= 390) {
						//碰底，检测是否被接住了
						if (this.x > panelSt - 10 && this.x < panelEn + 10) {
							this.ySpeed = -this.ySpeed;
							score += 5;
							//接住了，弹起并且加五分
						} else {
							//this.y += this.ySpeed;
							window.alert("完喽，寄了!");
							//this.x = 0;
							//this.y = 0;
							score = 0;
							flag = true;
							//没接住，积分清零并且初始化一些东西
						}
					} else {
						this.y += this.ySpeed; //Continue moving
					}
				}
			};
			var panel = {
				//声明挡板的基本属性
				//比如位置还有键盘控制的方法
				x: panelX,
				y: 390,
				xSize: 50,
				ySize: 5,
				draw: function() {
					ctx.fillStyle = "Black";
					ctx.fillRect(this.x, this.y, this.xSize, this.ySize); //Draw the panel
				}
			};

			function keyPanel(event) {
				if (event.keyCode == 65) {
					//‘a’被按下了，向左移动
					//console.log("Left!",testI);
					//testI++;
					panel.x -= 8;
					if (panel.x < 0) {
						panel.x = 0; //再移动就出左边界喽，所以移动到左边界就好
					}
				}
				if (event.keyCode == 68) {
					//‘d’被按下了，向右移动
					//console.log("Right!",testI);
					//testI++;
					panel.x += 8;
					if (panel.x > 400 - panel.xSize) {
						panel.x = 400 - panel.xSize; //再移动就出右边界喽，所以移动到右边界就好
						//注意哦，挡板的定位点在左上角诶
					}
				}
			}
			//调用debounce函数
			var dbPanelKey = debounce(keyPanel, 20);

			function leftClick() {
				panel.x -= 15;
				if (panel.x < 0) {
					panel.x = 0;
				}
				//如果向左按钮按下了就向左移动（总不会有人认为按钮还要除颤吧~）
			}

			function rightClick() {
				panel.x += 15;
				if (panel.x > 400 - panel.xSize) {
					panel.x = 400 - panel.xSize;
				}
				//同理，向右移动
			}
			const leftButton = document.createElement("button"); //创建向左按钮对象
			leftButton.innerText = "左"; //按钮文本
			leftButton.addEventListener("click", leftClick); //如果被点击那么执行方法移动挡板
			document.body.appendChild(leftButton); //让向左按钮出现
			const rightButton = document.createElement("button"); //向右按钮同理
			rightButton.innerText = "右"; 
			rightButton.addEventListener("click", rightClick); 
			document.body.appendChild(rightButton); 
			window.addEventListener("keydown", dbPanelKey); //检测是否有键盘按键按下
			//每隔20毫秒刷新一次弹球位置（更改这个就可以显著改变游戏难度哦~）
			setInterval(function() {
				if (flag == true) {
					//上一次寄了，所以重新生成小球和挡板的位置（也许可以但不能百分百避免游戏寄掉的死循环）
					prep();
					ball.x = startX;
					ball.y = startY;
					panel.x = panelX;
					flag = false;
				} else {
					ctx.clearRect(0, 0, 400, 400); //清除画布，不要留下轨迹
					ctx.font = "20px GenshinImpactZhLv1"; //选择积分显示字体
					ctx.fillText("分数：" + score, 10, 30); //在画布上显示最新积分
					ball.draw(); //调用方法绘制弹球
					panel.draw(); //调用方法绘制挡板
					ball.move(panel.x, panel.x + panel.xSize); //移动弹球，同时传入挡板最新位置，进行碰撞检测
					ctx.strokeRect(0, 0, 400, 400); //用黑线标记画布边界
				}
			}, 30);
		</script>
	</body>
</html>